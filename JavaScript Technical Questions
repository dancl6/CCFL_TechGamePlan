Explain event delegation.


This allows specifying an event listener on fewer HTML elements. Instead, it is specified on a parent element and then an event can be called for the child using a .target property.  It can be compared to a file structure on a computer with several folders in it. Each folder has several files, similar to how a single parent element can have multiple children elements with event listeners for each. It is basically like book keeping. If you have a parent div with 50 child divs that each require an event listener, that would be a large amount of typing that could be consolidated with an event delegation.  It can also be thought of as minimizing unnecessary coding. 



Explain how this works in JavaScript.


In an object, this refers to the object, in a function, this refers to the global object, alone, this refers to the global object.  There are generally variables within an object called properties and this can refer to those properties in an object. To compare and contrast, think of the this as a key card for an employee to get into their building of employment.  The building can be thought of as the object that the this (key card) belongs to and each building has several employees in it.  Another example is an object called car may have the properties mileage, color and weight. If you use this.weight, it refers to the property of weight in that object. The difference between ES5 and ES6 for the this keyword is that in ES5, the word “that” was part of the functionality of this and it was removed in ES6.


Can you give an example of one of the ways that working with this has changed in ES6?


The difference between ES5 and ES6 for the this keyword is that in ES5, the word “that” was part of the functionality of this and it was removed in ES6. This change simplified the functionality, removing “that” keyword. To compare and contrast, take the example of a building that is locked with two different keys.  Each time you need to lock or unlock the building, you need both keys, which takes more time and resources. By transitioning from ES5 to ES6 for “this” keyword, it would be similar to changing the locks so that you only need one key to get in. In the coding, you basically would remove one line of coding. This makes the code simpler and easier to understand.


Explain how prototypal inheritance works.

Prototypal inheritance is when an object inherits certain aspects of a prototype object, like methods/functions or state variables. This reduces the amount of coding necessary and allows for reusable object properties that are common.. To compare and contrast, prototypal inheritance is similar to the way a Toyota might be designed across different models.  They may use the same parts for several components which reduces the cost of making each component custom and also allows for using a design that’s been tested thoroughly.  One example from my own coding is through the use of an array, which uses prototypal  inheritance to inherit properties of a prototype object. I’ve also created several objects in a code that has the same properties but different values for that property, where the properties are inherited.



What’s the difference between a variable that is: null, undefined or undeclared?


Null means the intentional absence of a value for a variable and is treated as a false boolean value. Undefined means a variable has not been defined or not declared.  Undeclared means a variable was not declared using var, cont or let.  To compare and contrast, in the case of a locker, null would be like a locker with nothing in it. Undefined would be like a locker that has not been created yet. Undeclared would be like a locker that has not been assigned to anyone yet.   A personal example of an undeclared variable that I’ve run into in coding is if I use a variable that I have not declared with let, var or const.  However, these types of errors are generally easily found and corrected.


How would you go about checking for any of these states?


For null, you can check if a variable is false and also === null. For undefined you can check if a variable typeof(some-variable)=== “undefined”.  For undeclared, you will get an error in your code and it will be unable to compile, saying “is not defined”. 


What is a closure, and how/why would you use one?

A closure is a function within a function, where the inner function exposes the outer functions variables showing its lexical scope.  The inner function has access to the outer function’s variables. One use of closures is for data privacy because they describe what has access to what data (i.e. the inner function has access to the variables of the outer function). To compare and contrast, if you were working on a website’s security, you wouldn’t want any part of the code access to the variable values of any other part and you would want to control access as best  you could.  It would probably be a good idea to avoid creating a global variable that any part of the code can see or change because that would not be good for security. For example, it may not be a good idea to create a global variable for user id because that could be changed anywhere in the code and this wouldn’t give  you a good control of  it’s ability to be updated..  Updating a variable like user id is related to security and greater care should be taken for it.


What language constructions do you use for iterating over object properties and array items?


I tend to  use a for loop for iterating over an array.   I’ve grown accustomed to its syntax. For an array, I also use the .length option to find the end of the array. To compare and contrast to a while loop, the for loop has a more clearly defined end point. A while loop goes on until a criteria is reached so it is easier to have an infinite loop for a while loop, which causes problems. For example, a for loop will  only loop over the indices in the array and will stop at the end.  A while loop will continue to loop until the criteria is reached and if there is a bug or an issue with the logic, an infinite loop can be easily created accidentally


Can you describe the main difference between the Array.forEach() loop and Array.map() methods and why you would pick one versus the other?


The array.map() method returns a new array and the array.forEach() loop does not. The array.forEach() executes a function for each element of an array. The array.map() method will take an existing array, and transform it and return a new array. To compare and contrast, the array.forEach() may console.log something for each array element. But the array.map() may return a modification of the existing array, such as squaring the array value and returning the new array. For example, forEach might add each element of an array to database. 



Explain the difference between: function Person(){}, var person = Person(), and var person = new Person()?


The first argument is a function called Person, the second argument is assigning the function Person to the variable person and the third argument is creating a new object called person by inheriting the object prototype Person. So the first is a function, the second is a variable and the third is an object. To compare and contrast, the third argument would need an additional  object defined somewhere called Person() in order to create it. It wouldn’t be possible to create a new object based on a prototype object if the prototype didn’t exist.  One example from my personal coding is I needed to create an object with properties in order to feed info from the back end to the front end when I was using Handlebars. I created several objects, all based on the prototype object.


Explain the differences on the usage of foo between function foo() {} and var foo = function() {}

In the first argument, you are creating a function called foo.  In the second argument you are assigning a function to the variable foo. To compare and contrast, the first argument is a function and the second is a variable. The first example is similar to creating a website and the second is similar to creating a link to a website.

Explain Function.prototype.bind.

The bind() method creates a new function when it is called that connects the this keyword to a provided value.  It basically helps to avoid calling the global this and be more specific to avoid errors. To compare and contrast, I try not to have too many keys on my key ring to avoid confusion or unneeded keys, where I might get confused about which key is for which lock.  That’s similar to the this keyword which can be calling a global scope or a local scope and which may get the two confused.

What’s the difference between feature detection, feature inference, and using the UA string?

Feature detection is to identify the browser’s capabilities.  Feature Inference is to guess whether the browser has certain features based on feature detection. UA string is a string text of data that each browsers send and has info about the browser’s environment. To compare and contrast, feature detection would be like checking to see if there is milk in the fridge.  Feature inference would be like trying to infer whether we have bread if there is milk in the fridge because  you usually buy milk and bread at the same time.  So you basically are trying to guess if there is bread based on known info. 


Explain “hoisting”.

Hoisting is JavaScript’s default behavior of moving declarations to the top of the code body. If a variable is declared with var, its value can be used before it is declared.  For let and const, its value cannot be used before it is declared.

